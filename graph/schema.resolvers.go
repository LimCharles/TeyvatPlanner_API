package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"context"
	"fmt"
	"os"
	"teyvat_planner_api/auth"
	"teyvat_planner_api/graph/model"

	"github.com/golang-jwt/jwt"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, username string, email string, password string) (*model.User, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	var user model.User

	err = r.DB.QueryRow(
		ctx,
		"INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING id, username, email, password",
		username, email, string(hashedPassword),
	).Scan(&user.ID, &user.Username, &user.Email, &user.Password)

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// CreateCommission is the resolver for the createCommission field.
func (r *mutationResolver) CreateCommission(ctx context.Context, name string, category string) (*model.Commission, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var commission model.Commission

	err := r.DB.QueryRow(
		ctx,
		"INSERT INTO commissions (name, category, userID) VALUES ($1, $2, $3) RETURNING id, name, category, completed",
		name, category, authUser.ID,
	).Scan(&commission.ID, &commission.Name, &commission.Category, &commission.Completed)

	if err != nil {
		return nil, err
	}

	commission.User = &model.User{
		ID:       authUser.ID,
		Username: authUser.Username,
		Email:    authUser.Email,
	}

	return &commission, nil
}

// CreateDomain is the resolver for the createDomain field.
func (r *mutationResolver) CreateDomain(ctx context.Context, name string) (*model.Domain, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var domain model.Domain

	err := r.DB.QueryRow(
		ctx,
		"INSERT INTO domains (name, userID) VALUES ($1, $2) RETURNING id, name, completed",
		name, authUser.ID,
	).Scan(&domain.ID, &domain.Name, &domain.Completed)

	if err != nil {
		return nil, err
	}

	domain.User = &model.User{
		ID:       authUser.ID,
		Username: authUser.Username,
		Email:    authUser.Email,
	}

	return &domain, nil
}

// CreateWeeklyBoss is the resolver for the createWeeklyBoss field.
func (r *mutationResolver) CreateWeeklyBoss(ctx context.Context, name string) (*model.WeeklyBoss, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var weeklyBoss model.WeeklyBoss

	err := r.DB.QueryRow(
		ctx,
		"INSERT INTO weekly_bosses (name, userID) VALUES ($1, $2) RETURNING id, name, completed",
		name, authUser.ID,
	).Scan(&weeklyBoss.ID, &weeklyBoss.Name, &weeklyBoss.Completed)

	if err != nil {
		return nil, err
	}

	weeklyBoss.User = &model.User{
		ID:       authUser.ID,
		Username: authUser.Username,
		Email:    authUser.Email,
	}

	return &weeklyBoss, nil
}

// CreateRandomQuest is the resolver for the createRandomQuest field.
func (r *mutationResolver) CreateRandomQuest(ctx context.Context, name string, longitude *float64, latitude *float64) (*model.RandomQuest, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var randomQuest model.RandomQuest

	err := r.DB.QueryRow(
		ctx,
		"INSERT INTO random_quests (name, longitude, latitude, userID) VALUES ($1, $2, $3, $4) RETURNING id, name, longitude, latitude, completed",
		name, longitude, latitude, authUser.ID,
	).Scan(&randomQuest.ID, &randomQuest.Name, &randomQuest.Longitude, &randomQuest.Latitude, &randomQuest.Completed)

	if err != nil {
		return nil, err
	}

	randomQuest.User = &model.User{
		ID:       authUser.ID,
		Username: authUser.Username,
		Email:    authUser.Email,
	}

	return &randomQuest, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, username *string, email *string, password *string) (*model.User, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var user model.User

	query := `
		UPDATE users SET 
			username = COALESCE($1, username), 
			email = COALESCE($2, email), 
			password = COALESCE($3, password) 
		WHERE id = $4
		AND (
			($1 IS NOT NULL AND $1 IS DISTINCT FROM username) OR
			($2 IS NOT NULL AND $2 IS DISTINCT FROM email) OR
			($3 IS NOT NULL AND $3 IS DISTINCT FROM password)
		)
		RETURNING id, username, email, password
	`

	err := r.DB.QueryRow(
		ctx,
		query,
		username, email, password, id,
	).Scan(&user.ID, &user.Username, &user.Email, &user.Password)

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// UpdateCommission is the resolver for the updateCommission field.
func (r *mutationResolver) UpdateCommission(ctx context.Context, id string, name *string, category *string, completed *bool) (*model.Commission, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var commission model.Commission

	query := `
		UPDATE commissions SET
			name = COALESCE($1, name),
			category = COALESCE($2, category),
			completed = COALESCE($3, completed)
		WHERE id = $4
		AND (
			($1 IS NOT NULL AND $1 IS DISTINCT FROM name) OR
			($2 IS NOT NULL AND $2 IS DISTINCT FROM category) OR
			($3 IS NOT NULL AND $3 IS DISTINCT FROM completed)
		)
		RETURNING id, name, category, completed
	`

	err := r.DB.QueryRow(
		ctx,
		query,
		name, category, completed, id,
	).Scan(&commission.ID, &commission.Name, &commission.Category, &commission.Completed)

	if err != nil {
		return nil, err
	}

	commission.User = &model.User{
		ID:       authUser.ID,
		Username: authUser.Username,
		Email:    authUser.Email,
	}

	return &commission, nil
}

// UpdateDomain is the resolver for the updateDomain field.
func (r *mutationResolver) UpdateDomain(ctx context.Context, id string, name *string, completed *bool) (*model.Domain, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var domain model.Domain

	query := `
		UPDATE domains SET
			name = COALESCE($1, name),
			completed = COALESCE($2, completed)
		WHERE id = $3
		AND (
			($1 IS NOT NULL AND $1 IS DISTINCT FROM name) OR
			($2 IS NOT NULL AND $2 IS DISTINCT FROM completed)
		)
		RETURNING id, name, completed
	`

	err := r.DB.QueryRow(
		ctx,
		query,
		name, completed, id,
	).Scan(&domain.ID, &domain.Name, &domain.Completed)

	if err != nil {
		return nil, err
	}

	domain.User = &model.User{
		ID:       authUser.ID,
		Username: authUser.Username,
		Email:    authUser.Email,
	}

	return &domain, nil
}

// UpdateWeeklyBoss is the resolver for the updateWeeklyBoss field.
func (r *mutationResolver) UpdateWeeklyBoss(ctx context.Context, id string, name *string, completed *bool) (*model.WeeklyBoss, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var weeklyBoss model.WeeklyBoss

	query := `
		UPDATE weekly_bosses SET
			name = COALESCE($1, name),
			completed = COALESCE($2, completed)
		WHERE id = $3
		AND (
			($1 IS NOT NULL AND $1 IS DISTINCT FROM name) OR
			($2 IS NOT NULL AND $2 IS DISTINCT FROM completed)
		)
		RETURNING id, name, completed
	`

	err := r.DB.QueryRow(
		ctx,
		query,
		name, completed, id,
	).Scan(&weeklyBoss.ID, &weeklyBoss.Name, &weeklyBoss.Completed)

	if err != nil {
		return nil, err
	}

	weeklyBoss.User = &model.User{
		ID:       authUser.ID,
		Username: authUser.Username,
		Email:    authUser.Email,
	}

	return &weeklyBoss, nil
}

// UpdateRandomQuest is the resolver for the updateRandomQuest field.
func (r *mutationResolver) UpdateRandomQuest(ctx context.Context, id string, name *string, longitude *float64, latitude *float64, completed *bool) (*model.RandomQuest, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("Access Denied")
	}

	var randomQuest model.RandomQuest

	query := `
		UPDATE random_quests SET
			name = COALESCE($1, name),
			longitude = COALESCE($2, longitude),
			latitude = COALESCE($3, latitude),
			completed = COALESCE($4, completed)
		WHERE id = $5
		AND (
			($1 IS NOT NULL AND $1 IS DISTINCT FROM name) OR
			($2 IS NOT NULL AND $2 IS DISTINCT FROM longitude) OR
			($3 IS NOT NULL AND $3 IS DISTINCT FROM latitude) OR
			($4 IS NOT NULL AND $4 IS DISTINCT FROM completed)
		)
		RETURNING id, name, longitude, latitude, completed
	`

	err := r.DB.QueryRow(
		ctx,
		query,
		name, longitude, latitude, completed, id,
	).Scan(&randomQuest.ID, &randomQuest.Name, &randomQuest.Longitude, &randomQuest.Latitude, &randomQuest.Completed)

	if err != nil {
		return nil, err
	}

	randomQuest.User = &model.User{
		ID:       authUser.ID,
		Username: authUser.Username,
		Email:    authUser.Email,
	}

	return &randomQuest, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (string, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return "", fmt.Errorf("Access Denied")
	}

	cmdTag, err := r.DB.Exec(ctx, `DELETE FROM users WHERE id = $1`, id)
	if err != nil {
		return "", err
	}

	if cmdTag.RowsAffected() == 0 {
		return "", fmt.Errorf("no user found with ID %s", id)
	}

	return id, nil
}

// DeleteCommission is the resolver for the deleteCommission field.
func (r *mutationResolver) DeleteCommission(ctx context.Context, id string) (string, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return "", fmt.Errorf("Access Denied")
	}

	cmdTag, err := r.DB.Exec(ctx, `DELETE FROM commissions WHERE id = $1`, id)
	if err != nil {
		return "", err
	}

	if cmdTag.RowsAffected() == 0 {
		return "", fmt.Errorf("no commission found with ID %s", id)
	}

	return id, nil
}

// DeleteDomain is the resolver for the deleteDomain field.
func (r *mutationResolver) DeleteDomain(ctx context.Context, id string) (string, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return "", fmt.Errorf("Access Denied")
	}

	cmdTag, err := r.DB.Exec(ctx, `DELETE FROM domains WHERE id = $1`, id)
	if err != nil {
		return "", err
	}

	if cmdTag.RowsAffected() == 0 {
		return "", fmt.Errorf("no domain found with ID %s", id)
	}

	return id, nil
}

// DeleteWeeklyBoss is the resolver for the deleteWeeklyBoss field.
func (r *mutationResolver) DeleteWeeklyBoss(ctx context.Context, id string) (string, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return "", fmt.Errorf("Access Denied")
	}

	cmdTag, err := r.DB.Exec(ctx, `DELETE FROM weekly_bosses WHERE id = $1`, id)
	if err != nil {
		return "", err
	}

	if cmdTag.RowsAffected() == 0 {
		return "", fmt.Errorf("no weekly boss found with ID %s", id)
	}

	return id, nil
}

// DeleteRandomQuest is the resolver for the deleteRandomQuest field.
func (r *mutationResolver) DeleteRandomQuest(ctx context.Context, id string) (string, error) {
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return "", fmt.Errorf("Access Denied")
	}

	cmdTag, err := r.DB.Exec(ctx, `DELETE FROM random_quests WHERE id = $1`, id)
	if err != nil {
		return "", err
	}

	if cmdTag.RowsAffected() == 0 {
		return "", fmt.Errorf("no random quest found with ID %s", id)
	}

	return id, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	var userID string
	var hashedPassword string

	err := r.DB.QueryRow(
		ctx,
		"SELECT id, password FROM users WHERE email = $1",
		email,
	).Scan(&userID, &hashedPassword)

	if err != nil {
		return "", err
	}

	err = bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
	if err != nil {
		return "", err
	}

	claims := &jwt.StandardClaims{
		Issuer:  "TeyvatPlanner",
		Subject: userID,
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	refreshToken, err := token.SignedString([]byte(os.Getenv("TP_REFRESH_TOKEN_SECRET")))
	if err != nil {
		return "", err
	}

	return refreshToken, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// Commission is the resolver for the commission field.
func (r *queryResolver) Commission(ctx context.Context, id string) (*model.Commission, error) {
	panic(fmt.Errorf("not implemented: Commission - commission"))
}

// Commissions is the resolver for the commissions field.
func (r *queryResolver) Commissions(ctx context.Context) ([]*model.Commission, error) {
	panic(fmt.Errorf("not implemented: Commissions - commissions"))
}

// Domain is the resolver for the domain field.
func (r *queryResolver) Domain(ctx context.Context, id string) (*model.Domain, error) {
	panic(fmt.Errorf("not implemented: Domain - domain"))
}

// Domains is the resolver for the domains field.
func (r *queryResolver) Domains(ctx context.Context) ([]*model.Domain, error) {
	panic(fmt.Errorf("not implemented: Domains - domains"))
}

// WeeklyBoss is the resolver for the weeklyBoss field.
func (r *queryResolver) WeeklyBoss(ctx context.Context, id string) (*model.WeeklyBoss, error) {
	panic(fmt.Errorf("not implemented: WeeklyBoss - weeklyBoss"))
}

// WeeklyBosses is the resolver for the weeklyBosses field.
func (r *queryResolver) WeeklyBosses(ctx context.Context) ([]*model.WeeklyBoss, error) {
	panic(fmt.Errorf("not implemented: WeeklyBosses - weeklyBosses"))
}

// RandomQuest is the resolver for the randomQuest field.
func (r *queryResolver) RandomQuest(ctx context.Context, id string) (*model.RandomQuest, error) {
	panic(fmt.Errorf("not implemented: RandomQuest - randomQuest"))
}

// RandomQuests is the resolver for the randomQuests field.
func (r *queryResolver) RandomQuests(ctx context.Context) ([]*model.RandomQuest, error) {
	panic(fmt.Errorf("not implemented: RandomQuests - randomQuests"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
